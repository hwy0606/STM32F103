; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\RTE\_STM32-FD-ADC -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;180    ****************************************************************************/ 
;;;181    void ADC_Configuration(void)
000000  b570              PUSH     {r4-r6,lr}
;;;182    {
000002  b092              SUB      sp,sp,#0x48
;;;183    	ADC_InitTypeDef ADC_InitStructure;
;;;184    	GPIO_InitTypeDef GPIO_InitStructure;
;;;185    	DMA_InitTypeDef DMA_InitStructure;
;;;186    
;;;187        //设置AD模拟输入端口为输入 1路AD 规则通道
;;;188      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000004  2002              MOVS     r0,#2
000006  f8ad0040          STRH     r0,[sp,#0x40]
;;;189      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00000a  2400              MOVS     r4,#0
00000c  f88d4043          STRB     r4,[sp,#0x43]
;;;190      	GPIO_Init(GPIOC, &GPIO_InitStructure);
000010  a910              ADD      r1,sp,#0x40
000012  4831              LDR      r0,|L1.216|
000014  f7fffffe          BL       GPIO_Init
;;;191    	/* Enable DMA clock */
;;;192        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;193    
;;;194       /* Enable ADC1 and GPIOC clock */
;;;195        RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
000020  2101              MOVS     r1,#1
000022  0248              LSLS     r0,r1,#9
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;196    
;;;197      	/* DMA channel1 configuration ----------------------------------------------*/
;;;198    	//使能DMA
;;;199    	DMA_DeInit(DMA1_Channel1);
000028  4e2c              LDR      r6,|L1.220|
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       DMA_DeInit
;;;200    	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;			            //DMA通道1的地址 
000030  482b              LDR      r0,|L1.224|
;;;201    	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;	            //DMA传送地址
000032  9000              STR      r0,[sp,#0]
000034  482b              LDR      r0,|L1.228|
;;;202    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;					            //传送方向
;;;203    	DMA_InitStructure.DMA_BufferSize = 1;								            //传送内存大小，1个16位
000036  a901              ADD      r1,sp,#4
000038  2501              MOVS     r5,#1
00003a  e8810031          STM      r1,{r0,r4,r5}
;;;204    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	 
;;;205    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				            //传送内存地址递增
00003e  2080              MOVS     r0,#0x80
000040  e9cd4004          STRD     r4,r0,[sp,#0x10]
;;;206    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;		//ADC1转换的数据是16位
000044  0040              LSLS     r0,r0,#1
;;;207    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;				//传送的目的地址是16位宽度
000046  9006              STR      r0,[sp,#0x18]
000048  0080              LSLS     r0,r0,#2
;;;208    	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;									//循环
00004a  9007              STR      r0,[sp,#0x1c]
00004c  2020              MOVS     r0,#0x20
;;;209    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00004e  9008              STR      r0,[sp,#0x20]
000050  0200              LSLS     r0,r0,#8
;;;210    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;211    	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000052  e9cd0409          STRD     r0,r4,[sp,#0x24]
000056  4669              MOV      r1,sp
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       DMA_Init
;;;212        
;;;213    	/* 允许DMA1通道1传输结束中断 */
;;;214    	//DMA_ITConfig(DMA1_Channel1,DMA_IT_TC, ENABLE);
;;;215    
;;;216    
;;;217    	//使能DMA通道1
;;;218    	DMA_Cmd(DMA1_Channel1, ENABLE); 
00005e  2101              MOVS     r1,#1
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       DMA_Cmd
;;;219      
;;;220      
;;;221    	//ADC配置
;;;222    	/* ADC转换时间： ─ STM32F103xx增强型产品：时钟为56MHz时为1μs(时钟为72MHz为1.17μs)
;;;223    	ADC采样范围0-3.3V    */
;;;224    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);                   //设置ADC的时钟为72MHZ/6=12M 
000066  03e8              LSLS     r0,r5,#15
000068  f7fffffe          BL       RCC_ADCCLKConfig
;;;225    
;;;226    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC1工作在独立模式
;;;227    	ADC_InitStructure.ADC_ScanConvMode = ENABLE;		//模数转换工作在扫描模式（多通道）还是单次（单通道）模式
00006c  f88d5030          STRB     r5,[sp,#0x30]
000070  940b              STR      r4,[sp,#0x2c]
;;;228    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	//模数转换工作在连续模式，还是单次模式
000072  f88d5031          STRB     r5,[sp,#0x31]
;;;229    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//转换由软件而不是外部触发启动
000076  f44f2060          MOV      r0,#0xe0000
00007a  e9cd040d          STRD     r0,r4,[sp,#0x34]
;;;230    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC数据右对齐
;;;231    	ADC_InitStructure.ADC_NbrOfChannel = 1;               //规定了顺序进行规则转换的ADC通道的数目。这个数目的取值范围是1到16
;;;232    	ADC_Init(ADC1, &ADC_InitStructure);
00007e  4c18              LDR      r4,|L1.224|
000080  f88d503c          STRB     r5,[sp,#0x3c]         ;231
000084  3c4c              SUBS     r4,r4,#0x4c
000086  a90b              ADD      r1,sp,#0x2c
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       ADC_Init
;;;233    	
;;;234    	/* ADC1 regular channels configuration [规则模式通道配置]*/ 
;;;235    
;;;236    	//ADC1 规则通道配置
;;;237      	ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5);	  //通道11采样时间 55.5周期
00008e  2305              MOVS     r3,#5
000090  2201              MOVS     r2,#1
000092  210b              MOVS     r1,#0xb
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       ADC_RegularChannelConfig
;;;238      	
;;;239    
;;;240    	//使能ADC1 DMA 
;;;241    	ADC_DMACmd(ADC1, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       ADC_DMACmd
;;;242    	//使能ADC1
;;;243    	ADC_Cmd(ADC1, ENABLE);	
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       ADC_Cmd
;;;244    	
;;;245    	// 初始化ADC1校准寄存器
;;;246    	ADC_ResetCalibration(ADC1);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       ADC_ResetCalibration
                  |L1.176|
;;;247    	//检测ADC1校准寄存器初始化是否完成
;;;248    	while(ADC_GetResetCalibrationStatus(ADC1));
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000b6  2800              CMP      r0,#0
0000b8  d1fa              BNE      |L1.176|
;;;249    	
;;;250    	//开始校准ADC1
;;;251    	ADC_StartCalibration(ADC1);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       ADC_StartCalibration
                  |L1.192|
;;;252    	//检测是否完成校准
;;;253    	while(ADC_GetCalibrationStatus(ADC1));
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       ADC_GetCalibrationStatus
0000c6  2800              CMP      r0,#0
0000c8  d1fa              BNE      |L1.192|
;;;254    	
;;;255    	//ADC1转换启动
;;;256    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	 
0000ca  2101              MOVS     r1,#1
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;257    }
0000d2  b012              ADD      sp,sp,#0x48
0000d4  bd70              POP      {r4-r6,pc}
;;;258    /****************************************************************************
                          ENDP

0000d6  0000              DCW      0x0000
                  |L1.216|
                          DCD      0x40011000
                  |L1.220|
                          DCD      0x40020008
                  |L1.224|
                          DCD      0x4001244c
                  |L1.228|
                          DCD      ||.data||+0x2

                          AREA ||i.KEY_Configuration||, CODE, READONLY, ALIGN=2

                  KEY_Configuration PROC
;;;133    *******************************************************************************/
;;;134    void KEY_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;135    {
;;;136        GPIO_InitTypeDef GPIO_InitStructure;
;;;137        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;138    
;;;139        //配置按键
;;;140        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;141        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000010  2020              MOVS     r0,#0x20
000012  f8ad0000          STRH     r0,[sp,#0]
;;;142        GPIO_Init(GPIOC, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4801              LDR      r0,|L2.32|
00001a  f7fffffe          BL       GPIO_Init
;;;143    }
00001e  bd08              POP      {r3,pc}
;;;144    /*******************************************************************************
                          ENDP

                  |L2.32|
                          DCD      0x40011000

                          AREA ||i.LED_Configuration||, CODE, READONLY, ALIGN=2

                  LED_Configuration PROC
;;;150    *******************************************************************************/
;;;151    void LED_Configuration(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;152    {
;;;153        GPIO_InitTypeDef GPIO_InitStructure;
;;;154        //使能LED所在GPIO的时钟
;;;155        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;156        //初始化LED的GPIO
;;;157    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000a  2410              MOVS     r4,#0x10
00000c  f88d4003          STRB     r4,[sp,#3]
;;;158    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  	
000010  2503              MOVS     r5,#3
000012  f88d5002          STRB     r5,[sp,#2]
;;;159    		GPIO_InitStructure.GPIO_Pin =  LED1;
000016  2020              MOVS     r0,#0x20
;;;160    	  GPIO_Init(GPIOB, &GPIO_InitStructure);	
000018  4e0f              LDR      r6,|L3.88|
00001a  f8ad0000          STRH     r0,[sp,#0]            ;159
00001e  4669              MOV      r1,sp
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       GPIO_Init
;;;161    		GPIO_SetBits(GPIOB, LED1);  //熄灭LED0-3
000026  2120              MOVS     r1,#0x20
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       GPIO_SetBits
;;;162    	
;;;163    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD , ENABLE);	
00002e  2101              MOVS     r1,#1
000030  2020              MOVS     r0,#0x20
000032  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;164    	  //初始化LED的GPIO
;;;165    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000036  f88d4003          STRB     r4,[sp,#3]
;;;166    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  f88d5002          STRB     r5,[sp,#2]
;;;167    		GPIO_InitStructure.GPIO_Pin =  LED2 | LED3;	 
00003e  2048              MOVS     r0,#0x48
;;;168    		GPIO_Init(GPIOD, &GPIO_InitStructure);			
000040  4c06              LDR      r4,|L3.92|
000042  f8ad0000          STRH     r0,[sp,#0]            ;167
000046  4669              MOV      r1,sp
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       GPIO_Init
;;;169      
;;;170        GPIO_SetBits(GPIOD, LED2 | LED3);  //熄灭LED0-3
00004e  2148              MOVS     r1,#0x48
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       GPIO_SetBits
;;;171    }
000056  bdf8              POP      {r3-r7,pc}
;;;172    
                          ENDP

                  |L3.88|
                          DCD      0x40010c00
                  |L3.92|
                          DCD      0x40011400

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;265    ****************************************************************************/ 
;;;266    void RCC_Configuration(void){
000000  b510              PUSH     {r4,lr}
;;;267    
;;;268      SystemInit(); 
000002  f7fffffe          BL       SystemInit
;;;269      RCC_ADCCLKConfig(RCC_PCLK2_Div6); 
000006  f44f4000          MOV      r0,#0x8000
00000a  f7fffffe          BL       RCC_ADCCLKConfig
;;;270      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;271      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;272      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
00001e  2101              MOVS     r1,#1
000020  0248              LSLS     r0,r1,#9
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;273      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC 
000026  2101              MOVS     r1,#1
000028  e8bd4010          POP      {r4,lr}
00002c  207c              MOVS     r0,#0x7c
00002e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;274      						| RCC_APB2Periph_GPIOD| RCC_APB2Periph_GPIOE , ENABLE);
;;;275    }
;;;276    
                          ENDP


                          AREA ||i.USART_OUT||, CODE, READONLY, ALIGN=1

                  USART_OUT PROC
;;;390    ****************************************************************************/
;;;391    void USART_OUT(USART_TypeDef* USARTx, uint8_t *Data,...){ 
000000  b40f              PUSH     {r0-r3}
000002  b57f              PUSH     {r0-r6,lr}
000004  4605              MOV      r5,r0
;;;392    
;;;393    	const char *s;
;;;394        int d;
;;;395       
;;;396        char buf[16];
;;;397        va_list ap;
;;;398        va_start(ap, Data);
000006  ac0a              ADD      r4,sp,#0x28
000008  e00f              B        |L5.42|
                  |L5.10|
;;;399    
;;;400    	while(*Data!=0){				                          //判断是否到达字符串结束符
;;;401    		if(*Data==0x5c){									  //'\'
00000a  295c              CMP      r1,#0x5c
00000c  d014              BEQ      |L5.56|
;;;402    			switch (*++Data){
;;;403    				case 'r':							          //回车符
;;;404    					USART_SendData(USARTx, 0x0d);	   
;;;405    
;;;406    					Data++;
;;;407    					break;
;;;408    				case 'n':							          //换行符
;;;409    					USART_SendData(USARTx, 0x0a);	
;;;410    					Data++;
;;;411    					break;
;;;412    				
;;;413    				default:
;;;414    					Data++;
;;;415    				    break;
;;;416    			}
;;;417    			
;;;418    			 
;;;419    		}
;;;420    		else if(*Data=='%'){									  //
00000e  f1020201          ADD      r2,r2,#1
000012  2925              CMP      r1,#0x25
000014  9209              STR      r2,[sp,#0x24]
000016  d01d              BEQ      |L5.84|
;;;421    			switch (*++Data){				
;;;422    				case 's':										  //字符串
;;;423                    	s = va_arg(ap, const char *);
;;;424                    	for ( ; *s; s++) {
;;;425                        	USART_SendData(USARTx,*s);
;;;426    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
;;;427                    	}
;;;428    					Data++;
;;;429                    	break;
;;;430                	case 'd':										  //十进制
;;;431                    	d = va_arg(ap, int);
;;;432                    	itoa(d, buf, 10);
;;;433                    	for (s = buf; *s; s++) {
;;;434                        	USART_SendData(USARTx,*s);
;;;435    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
;;;436                    	}
;;;437    					Data++;
;;;438                    	break;
;;;439    				default:
;;;440    					Data++;
;;;441    				    break;
;;;442    			}		 
;;;443    		}
;;;444    		else USART_SendData(USARTx, *Data++);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       USART_SendData
                  |L5.30|
;;;445    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
00001e  2140              MOVS     r1,#0x40
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       USART_GetFlagStatus
000026  2800              CMP      r0,#0
000028  d0f9              BEQ      |L5.30|
                  |L5.42|
00002a  9a09              LDR      r2,[sp,#0x24]         ;400
00002c  7811              LDRB     r1,[r2,#0]            ;400
00002e  2900              CMP      r1,#0                 ;400
000030  d1eb              BNE      |L5.10|
;;;446    	}
;;;447    }
000032  bc7f              POP      {r0-r6}
000034  f85dfb14          LDR      pc,[sp],#0x14
                  |L5.56|
000038  1c52              ADDS     r2,r2,#1
00003a  9209              STR      r2,[sp,#0x24]         ;402
00003c  7810              LDRB     r0,[r2,#0]            ;402
00003e  286e              CMP      r0,#0x6e              ;402
000040  d003              BEQ      |L5.74|
000042  2872              CMP      r0,#0x72              ;402
000044  d10b              BNE      |L5.94|
000046  210d              MOVS     r1,#0xd               ;404
000048  e000              B        |L5.76|
                  |L5.74|
00004a  210a              MOVS     r1,#0xa               ;409
                  |L5.76|
00004c  4628              MOV      r0,r5                 ;409
00004e  f7fffffe          BL       USART_SendData
000052  e016              B        |L5.130|
                  |L5.84|
000054  7810              LDRB     r0,[r2,#0]            ;421
000056  2864              CMP      r0,#0x64              ;421
000058  d017              BEQ      |L5.138|
00005a  2873              CMP      r0,#0x73              ;421
00005c  d002              BEQ      |L5.100|
                  |L5.94|
00005e  1c52              ADDS     r2,r2,#1              ;421
000060  9209              STR      r2,[sp,#0x24]         ;441
000062  e7dc              B        |L5.30|
                  |L5.100|
000064  cc40              LDM      r4!,{r6}              ;423
000066  e009              B        |L5.124|
                  |L5.104|
000068  4628              MOV      r0,r5                 ;425
00006a  f7fffffe          BL       USART_SendData
                  |L5.110|
00006e  2140              MOVS     r1,#0x40              ;426
000070  4628              MOV      r0,r5                 ;426
000072  f7fffffe          BL       USART_GetFlagStatus
000076  2800              CMP      r0,#0                 ;426
000078  d0f9              BEQ      |L5.110|
00007a  1c76              ADDS     r6,r6,#1              ;426
                  |L5.124|
00007c  7831              LDRB     r1,[r6,#0]            ;424
00007e  2900              CMP      r1,#0                 ;424
000080  d1f2              BNE      |L5.104|
                  |L5.130|
000082  9809              LDR      r0,[sp,#0x24]         ;428
000084  1c40              ADDS     r0,r0,#1              ;428
000086  9009              STR      r0,[sp,#0x24]         ;429
000088  e7c9              B        |L5.30|
                  |L5.138|
00008a  cc01              LDM      r4!,{r0}              ;431
00008c  220a              MOVS     r2,#0xa               ;432
00008e  4669              MOV      r1,sp                 ;432
000090  f7fffffe          BL       itoa
000094  466e              MOV      r6,sp                 ;433
000096  e009              B        |L5.172|
                  |L5.152|
000098  4628              MOV      r0,r5                 ;434
00009a  f7fffffe          BL       USART_SendData
                  |L5.158|
00009e  2140              MOVS     r1,#0x40              ;435
0000a0  4628              MOV      r0,r5                 ;435
0000a2  f7fffffe          BL       USART_GetFlagStatus
0000a6  2800              CMP      r0,#0                 ;435
0000a8  d0f9              BEQ      |L5.158|
0000aa  1c76              ADDS     r6,r6,#1              ;435
                  |L5.172|
0000ac  7831              LDRB     r1,[r6,#0]            ;433
0000ae  2900              CMP      r1,#0                 ;433
0000b0  d1f2              BNE      |L5.152|
0000b2  e7e6              B        |L5.130|
;;;448    /******************* (C) COPYRIGHT 2013 奋斗STM32 *****END OF FILE****/
                          ENDP


                          AREA ||i.Usart1_Init||, CODE, READONLY, ALIGN=2

                  Usart1_Init PROC
;;;284    ****************************************************************************/
;;;285    void Usart1_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
;;;287      GPIO_InitTypeDef GPIO_InitStructure;
;;;288      USART_InitTypeDef USART_InitStructure;
;;;289     
;;;290      RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 , ENABLE);	 //使能串口1时钟
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;286
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;291    
;;;292      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; 			      //LCD背光控制
00000c  f44f5400          MOV      r4,#0x2000
000010  f8ad4000          STRH     r4,[sp,#0]
;;;293      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2503              MOVS     r5,#3
000016  f88d5002          STRB     r5,[sp,#2]
;;;294      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00001a  2010              MOVS     r0,#0x10
;;;295      GPIO_Init(GPIOD, &GPIO_InitStructure);
00001c  4e1d              LDR      r6,|L6.148|
00001e  f88d0003          STRB     r0,[sp,#3]            ;294
000022  4669              MOV      r1,sp
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       GPIO_Init
;;;296      GPIO_ResetBits(GPIOD, GPIO_Pin_13);			              //LCD背光关闭	
00002a  4621              MOV      r1,r4
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       GPIO_ResetBits
;;;297    
;;;298      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;	         		 //USART1 TX
000032  1120              ASRS     r0,r4,#4
000034  f8ad0000          STRH     r0,[sp,#0]
;;;299      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000038  f88d5002          STRB     r5,[sp,#2]
;;;300      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    		 //复用推挽输出
00003c  2018              MOVS     r0,#0x18
;;;301      GPIO_Init(GPIOA, &GPIO_InitStructure);		    		 //A端口 
00003e  4c16              LDR      r4,|L6.152|
000040  f88d0003          STRB     r0,[sp,#3]            ;300
000044  4669              MOV      r1,sp
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       GPIO_Init
;;;302    
;;;303      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;	         	 //USART1 RX
00004c  1520              ASRS     r0,r4,#20
00004e  f8ad0000          STRH     r0,[sp,#0]
;;;304      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   	 //复用开漏输入
000052  2004              MOVS     r0,#4
000054  f88d0003          STRB     r0,[sp,#3]
;;;305      GPIO_Init(GPIOA, &GPIO_InitStructure);		         	 //A端口 
000058  4669              MOV      r1,sp
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       GPIO_Init
;;;306    
;;;307      USART_InitStructure.USART_BaudRate = 9600;						//速率115200bps
000060  f44f5016          MOV      r0,#0x2580
;;;308      USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//数据位8位
000064  9001              STR      r0,[sp,#4]
000066  2000              MOVS     r0,#0
000068  f8ad0008          STRH     r0,[sp,#8]
;;;309      USART_InitStructure.USART_StopBits = USART_StopBits_1;			//停止位1位
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;310      USART_InitStructure.USART_Parity = USART_Parity_No;				//无校验位
000070  f8ad000c          STRH     r0,[sp,#0xc]
;;;311      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;   //无硬件流控
000074  f8ad0010          STRH     r0,[sp,#0x10]
;;;312      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;					//收发模式
000078  200c              MOVS     r0,#0xc
;;;313    
;;;314      /* Configure USART1 */
;;;315      USART_Init(USART1, &USART_InitStructure);							//配置串口参数函数   
00007a  4c08              LDR      r4,|L6.156|
00007c  f8ad000e          STRH     r0,[sp,#0xe]          ;312
000080  a901              ADD      r1,sp,#4
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       USART_Init
;;;316       /* Enable the USART1 */
;;;317      USART_Cmd(USART1, ENABLE);	
000088  2101              MOVS     r1,#1
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       USART_Cmd
;;;318      
;;;319    }
000090  b006              ADD      sp,sp,#0x18
000092  bd70              POP      {r4-r6,pc}
;;;320    /******************************************************
                          ENDP

                  |L6.148|
                          DCD      0x40011400
                  |L6.152|
                          DCD      0x40010800
                  |L6.156|
                          DCD      0x40013800

                          AREA ||i.iap_jump||, CODE, READONLY, ALIGN=2

                  iap_jump PROC
;;;110    //=============================================================================================
;;;111    void iap_jump(u32 iapxaddr)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113    	if(((*(vu32*)iapxaddr)&0x2FFE0000)==0x20000000)	//检查栈顶地址是否合法.0x20000000是sram的起始地址,也是程序的栈顶地址
000002  6801              LDR      r1,[r0,#0]
000004  4a07              LDR      r2,|L7.36|
000006  4011              ANDS     r1,r1,r2
000008  f1b15f00          CMP      r1,#0x20000000
00000c  d109              BNE      |L7.34|
;;;114    	{ 
;;;115    //		printf("ok\r\n");
;;;116    		//Delay_Ms(10);
;;;117    		jump2iap=(iapfun)*(vu32*)(iapxaddr+4);		//用户代码区第二个字为程序开始地址(复位地址)		
00000e  6841              LDR      r1,[r0,#4]
000010  4c05              LDR      r4,|L7.40|
;;;118    	//	MSR_MSP(*(vu32*)iapxaddr);					//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)
;;;119    		__set_MSP(*(__IO uint32_t*) iapxaddr);
000012  60a1              STR      r1,[r4,#8]  ; jump2iap
000014  6800              LDR      r0,[r0,#0]
000016  f7fffffe          BL       __set_MSP
;;;120    		jump2iap();									//跳转到APP.
00001a  68a0              LDR      r0,[r4,#8]  ; jump2iap
00001c  e8bd4010          POP      {r4,lr}
000020  4700              BX       r0
                  |L7.34|
;;;121    	}
;;;122    	else
;;;123    	{
;;;124    //		printf("iap program loss,please check\r\n");
;;;125    	}
;;;126    }
000022  bd10              POP      {r4,pc}
;;;127    /*******************************************************************************
                          ENDP

                  |L7.36|
                          DCD      0x2ffe0000
                  |L7.40|
                          DCD      ||.data||

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=2

                  itoa PROC
;;;329    **********************************************************/
;;;330    char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;331    {
;;;332        int     i, d;
;;;333        int     flag = 0;
000002  2600              MOVS     r6,#0
;;;334        char    *ptr = string;
000004  460b              MOV      r3,r1
000006  4635              MOV      r5,r6
;;;335    
;;;336        /* This implementation only works for decimal numbers. */
;;;337        if (radix != 10)
000008  2a0a              CMP      r2,#0xa
00000a  d002              BEQ      |L8.18|
;;;338        {
;;;339            *ptr = 0;
00000c  700d              STRB     r5,[r1,#0]
;;;340            return string;
00000e  4618              MOV      r0,r3
;;;341        }
;;;342    
;;;343        if (!value)
;;;344        {
;;;345            *ptr++ = 0x30;
;;;346            *ptr = 0;
;;;347            return string;
;;;348        }
;;;349    
;;;350        /* if this is a negative value insert the minus sign. */
;;;351        if (value < 0)
;;;352        {
;;;353            *ptr++ = '-';
;;;354    
;;;355            /* Make the value positive. */
;;;356            value *= -1;
;;;357        }
;;;358    
;;;359        for (i = 10000; i > 0; i /= 10)
;;;360        {
;;;361            d = value / i;
;;;362    
;;;363            if (d || flag)
;;;364            {
;;;365                *ptr++ = (char)(d + 0x30);
;;;366                value -= (d * i);
;;;367                flag = 1;
;;;368            }
;;;369        }
;;;370    
;;;371        /* Null terminate the string. */
;;;372        *ptr = 0;
;;;373    
;;;374        return string;
;;;375    
;;;376    } /* NCL_Itoa */
000010  bdf0              POP      {r4-r7,pc}
                  |L8.18|
000012  2800              CMP      r0,#0                 ;343
000014  d01f              BEQ      |L8.86|
000016  da06              BGE      |L8.38|
000018  f04f022d          MOV      r2,#0x2d              ;353
00001c  701a              STRB     r2,[r3,#0]            ;353
00001e  f1010301          ADD      r3,r1,#1              ;353
000022  f1c00000          RSB      r0,r0,#0              ;356
                  |L8.38|
000026  f2427410          MOV      r4,#0x2710            ;359
00002a  f04f070a          MOV      r7,#0xa               ;331
00002e  bf00              NOP                            ;361
                  |L8.48|
000030  fb90f2f4          SDIV     r2,r0,r4              ;361
000034  ea520c06          ORRS     r12,r2,r6             ;363
000038  d006              BEQ      |L8.72|
00003a  f1020630          ADD      r6,r2,#0x30           ;365
00003e  f8036b01          STRB     r6,[r3],#1            ;365
000042  fb020014          MLS      r0,r2,r4,r0           ;366
000046  2601              MOVS     r6,#1                 ;367
                  |L8.72|
000048  fb94f4f7          SDIV     r4,r4,r7              ;359
00004c  2c00              CMP      r4,#0                 ;359
00004e  dcef              BGT      |L8.48|
                  |L8.80|
000050  701d              STRB     r5,[r3,#0]            ;372
000052  4608              MOV      r0,r1                 ;374
000054  bdf0              POP      {r4-r7,pc}
                  |L8.86|
000056  2030              MOVS     r0,#0x30              ;345
000058  7018              STRB     r0,[r3,#0]            ;345
00005a  1c4b              ADDS     r3,r1,#1              ;345
00005c  e7f8              B        |L8.80|
;;;377    /****************************************************************************
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;64     ****************************************************************************/ 
;;;65     int main(void)
000000  f7fffffe          BL       RCC_Configuration
;;;66     {	
;;;67     	static  _Bool flag_ledtoogle=0;
;;;68       RCC_Configuration();	             //设置内部时钟及外设时钟使能
;;;69     	LED_Configuration();
000004  f7fffffe          BL       LED_Configuration
;;;70     	KEY_Configuration();
000008  f7fffffe          BL       KEY_Configuration
;;;71       Usart1_Init();		             //串口1初始化  
00000c  f7fffffe          BL       Usart1_Init
;;;72       ADC_Configuration();				 //ADC初始化
000010  f7fffffe          BL       ADC_Configuration
;;;73       USART_OUT(USART1,"\r\n USART1 print AD_value -------------------------- \r\n"); 
000014  4c29              LDR      r4,|L9.188|
000016  a11b              ADR      r1,|L9.132|
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       USART_OUT
00001e  46a0              MOV      r8,r4
;;;74       while(1)
;;;75       {
;;;76       	 if (ticks++ >= 900000) 
000020  4e27              LDR      r6,|L9.192|
;;;77     		{        //间隔时间显示转换结果
;;;78     			ticks   = 0;
;;;79     			Clock1s = 1;
000022  2701              MOVS     r7,#1
;;;80     			flag_ledtoogle^=1;
;;;81     		}
;;;82     		if(flag_ledtoogle)
;;;83     		{
;;;84     				GPIO_ResetBits(GPIOB, LED1);  //熄灭LED0-3	
000024  f8dfb09c          LDR      r11,|L9.196|
000028  4c27              LDR      r4,|L9.200|
;;;85     		}		
;;;86     		else
;;;87     		{
;;;88     				GPIO_SetBits(GPIOB, LED1);  //熄灭LED0-3	
;;;89     		}
;;;90     	 if (Clock1s) 
;;;91     		 {
;;;92     				Clock1s = 0;   
;;;93     					 
;;;94     				USART_OUT(USART1,"The current AD value = %d \r\n", ADC_ConvertedValue);
;;;95          }  
;;;96     		 
;;;97     		 if (GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_5)  == 0x00)
00002a  f8df90a0          LDR      r9,|L9.204|
00002e  2500              MOVS     r5,#0                 ;84
;;;98     		 {
;;;99     				iap_jump(FLASH_IAP_ADDR);
000030  f04f6a00          MOV      r10,#0x8000000
                  |L9.52|
000034  6860              LDR      r0,[r4,#4]            ;76  ; ticks
000036  1c41              ADDS     r1,r0,#1              ;76
000038  6061              STR      r1,[r4,#4]            ;76  ; ticks
00003a  42b0              CMP      r0,r6                 ;76
00003c  d305              BCC      |L9.74|
00003e  6065              STR      r5,[r4,#4]            ;79  ; ticks
000040  7067              STRB     r7,[r4,#1]            ;79
000042  7820              LDRB     r0,[r4,#0]            ;80  ; flag_ledtoogle
000044  f0800001          EOR      r0,r0,#1              ;80
000048  7020              STRB     r0,[r4,#0]            ;80
                  |L9.74|
00004a  7820              LDRB     r0,[r4,#0]            ;82  ; flag_ledtoogle
00004c  f04f0120          MOV      r1,#0x20              ;88
000050  2800              CMP      r0,#0                 ;82
000052  4658              MOV      r0,r11                ;88
000054  d002              BEQ      |L9.92|
000056  f7fffffe          BL       GPIO_ResetBits
00005a  e001              B        |L9.96|
                  |L9.92|
00005c  f7fffffe          BL       GPIO_SetBits
                  |L9.96|
000060  7860              LDRB     r0,[r4,#1]            ;90  ; Clock1s
000062  b128              CBZ      r0,|L9.112|
000064  7065              STRB     r5,[r4,#1]            ;92
000066  8862              LDRH     r2,[r4,#2]            ;94  ; ADC_ConvertedValue
000068  a119              ADR      r1,|L9.208|
00006a  4640              MOV      r0,r8                 ;94
00006c  f7fffffe          BL       USART_OUT
                  |L9.112|
000070  2120              MOVS     r1,#0x20              ;97
000072  4648              MOV      r0,r9                 ;97
000074  f7fffffe          BL       GPIO_ReadInputDataBit
000078  2800              CMP      r0,#0                 ;97
00007a  d1db              BNE      |L9.52|
00007c  4650              MOV      r0,r10
00007e  f7fffffe          BL       iap_jump
000082  e7d7              B        |L9.52|
;;;100    		 }
;;;101      }
;;;102    }
;;;103    //=============================================================================================
                          ENDP

                  |L9.132|
000084  0d0a2055          DCB      "\r\n USART1 print AD_value -------------------------- \r"
000088  53415254
00008c  31207072
000090  696e7420
000094  41445f76
000098  616c7565
00009c  202d2d2d
0000a0  2d2d2d2d
0000a4  2d2d2d2d
0000a8  2d2d2d2d
0000ac  2d2d2d2d
0000b0  2d2d2d2d
0000b4  2d2d2d20
0000b8  0d      
0000b9  0a00              DCB      "\n",0
0000bb  00                DCB      0
                  |L9.188|
                          DCD      0x40013800
                  |L9.192|
                          DCD      0x000dbba0
                  |L9.196|
                          DCD      0x40010c00
                  |L9.200|
                          DCD      ||.data||
                  |L9.204|
                          DCD      0x40011000
                  |L9.208|
0000d0  54686520          DCB      "The current AD value = %d \r\n",0
0000d4  63757272
0000d8  656e7420
0000dc  41442076
0000e0  616c7565
0000e4  203d2025
0000e8  64200d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  flag_ledtoogle
000000  00                DCB      0x00
                  Clock1s
000001  00                DCB      0x00
                  ADC_ConvertedValue
000002  0000              DCB      0x00,0x00
                  ticks
                          DCD      0x00000000
                  jump2iap
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
